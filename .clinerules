# TONゲーム プロジェクトルール

<!-- 2025/3/17: メモリバンク初期化時に作成。プロジェクト固有のパターンと規則を記録 -->

## プロジェクト構造のルール

1. **Next.js 14 App Routerの使用**:
   - `pages/` ディレクトリは使用せず、すべてのルーティングは `app/` ディレクトリで行う
   - ページコンポーネントは `page.tsx` という名前で作成する
   - レイアウトコンポーネントは `layout.tsx` という名前で作成する
   - APIルートは `app/api/[route]/route.ts` の形式で作成する

2. **ディレクトリ構造**:
   - コンポーネントは `components/` ディレクトリに配置する
   - ユーティリティ関数は `lib/` ディレクトリに配置する
   - サービスレイヤーは `services/` ディレクトリに配置する
   - 型定義は `types/` ディレクトリに配置する

3. **命名規則**:
   - コンポーネントはパスカルケース（例: `QuestCard.tsx`）
   - ユーティリティ関数とサービスはキャメルケース（例: `formatDate.ts`）
   - 定数は大文字のスネークケース（例: `MAX_QUESTS`）
   - 型定義はパスカルケースで接尾辞に `Type` を付ける（例: `UserType`）

## コーディングスタイル

1. **TypeScript**:
   - 厳格な型チェックを使用する（`tsconfig.json` の `strict: true`）
   - `any` 型の使用を避け、明示的な型定義を行う
   - 非同期関数の戻り値型は `Promise<T>` と明示する

2. **React**:
   - 関数コンポーネントと React Hooks を使用する
   - クラスコンポーネントは使用しない
   - コンポーネントのプロパティは明示的に型定義する

3. **Tailwind CSS**:
   - ユーティリティクラスを直接使用する
   - 複雑なスタイルは `@apply` ディレクティブを使用して抽出する
   - カスタムカラーは `tailwind.config.js` で定義する

4. **コンポーネント設計**:
   - 単一責任の原則に従う
   - 再利用可能なコンポーネントを作成する
   - プロップドリリングを避け、コンテキストを適切に使用する

## カラースキームとデザイン

1. **ユーザーUI**:
   - メイン色: #3B1E66 (Deep Violet)
   - 背景色: #100C19 (Black Purple)
   - テキスト色: #FFFFFF (White)
   - ボタン色: #3A1F65 (Rich Violet)
   - アクセント色: #E67E22 (Orange)

2. **管理者UI**:
   - 背景色: #181225 (Dark Purple)
   - テキスト色: #FFFFFF (White)
   - データアクセント: #3B1E66 (Deep Violet)
   - ボタン色: #3A1F65 (Rich Violet)
   - 警告色: #E74C3C (Red)

3. **フォント**:
   - 'Good Times' フォント（Adobe Typekit経由）
   - インクルード方法: `<link rel="stylesheet" href="https://use.typekit.net/akn4ocf.css">`

## API設計

1. **エンドポイント命名**:
   - RESTful原則に従う
   - 複数形の名詞を使用する（例: `/api/quests`）
   - 動詞はHTTPメソッドで表現する（GET, POST, PUT, DELETE）

2. **レスポンス形式**:
   - すべてのレスポンスはJSON形式
   - 成功レスポンスは `{ success: true, data: ... }` の形式
   - エラーレスポンスは `{ success: false, error: { message: '...', code: '...' } }` の形式

3. **認証**:
   - すべての認証済みAPIリクエストはAuthorizationヘッダーにJWTトークンを含める
   - 認証が必要なエンドポイントは認証ミドルウェアを使用する

## データベース設計

1. **テーブル命名**:
   - 複数形の名詞を使用する（例: `users`, `quests`）
   - 中間テーブルは関連する2つのテーブル名を結合する（例: `user_quests`）

2. **列命名**:
   - スネークケースを使用する（例: `created_at`）
   - 主キーは `id` とする
   - 外部キーは `[テーブル名の単数形]_id` とする（例: `user_id`）
   - タイムスタンプ列は `created_at`, `updated_at` とする

3. **Row Level Security (RLS)**:
   - すべてのテーブルにRLSポリシーを設定する
   - ユーザーは自分のデータのみにアクセス可能
   - 管理者は特定のテーブルに対して広範なアクセス権を持つ

## 認証とセキュリティ

1. **認証フロー**:
   - Telegram OAuthを主要な認証方法として使用
   - Supabase Authでユーザーデータを管理
   - Clerk Authで追加の認証機能を提供
   - JWTでセッション管理を行う

2. **セキュリティ対策**:
   - すべての入力データをバリデーション
   - センシティブデータは暗号化して保存
   - CSRFトークンを使用
   - レート制限を実装

## テスト戦略

1. **ユニットテスト**:
   - Jestを使用
   - コンポーネントとユーティリティ関数をテスト
   - モックを適切に使用

2. **統合テスト**:
   - React Testing Libraryを使用
   - コンポーネント間の相互作用をテスト

3. **E2Eテスト**:
   - Cypressを使用
   - 主要なユーザーフローをテスト

## デプロイメント

1. **環境**:
   - 開発環境: ローカル開発サーバー
   - ステージング環境: Vercel/Netlifyのプレビュー環境
   - 本番環境: Vercel/Netlify

2. **CI/CD**:
   - GitHub Actionsを使用
   - プルリクエスト時に自動テスト
   - マージ時に自動デプロイ

## 既知の課題と対応策

1. **認証システムの複雑性**:
   - 課題: 複数の認証システムの統合による複雑性
   - 対応策: 認証フローの明確な設計と各システムの役割の明確化

2. **Unity WebGLのパフォーマンス**:
   - 課題: モバイルデバイスでのWebGLパフォーマンスと初期ロード時間
   - 対応策: アセットの最適化、プログレッシブローディング、代替の軽量モードの検討

3. **APIレート制限**:
   - 課題: 外部サービスのレート制限
   - 対応策: キャッシュ戦略と指数バックオフメカニズムの実装

## ユーザー好みと要望

このセクションは、ユーザーとの対話を通じて学んだ好みや要望を記録するために使用します。プロジェクトの進行に伴って更新されます。

## 開発ワークフロー

1. **機能開発**:
   - 機能ブランチを作成 (`feature/feature-name`)
   - 開発とローカルテスト
   - プルリクエスト作成
   - コードレビュー
   - マージ

2. **バグ修正**:
   - バグ修正ブランチを作成 (`fix/bug-description`)
   - 修正とテスト
   - プルリクエスト作成
   - コードレビュー
   - マージ

3. **リリース**:
   - リリースブランチを作成 (`release/vX.Y.Z`)
   - 最終テスト
   - 本番環境へのデプロイ
   - リリースタグの作成

4. **緊急修正**:
   - ホットフィックスブランチを作成 (`hotfix/issue-description`)
   - 修正と検証
   - 本番環境へのデプロイ
   - 開発ブランチへのバックポート

## 重要な実装パス

このセクションは、プロジェクトの進行に伴って、重要な実装パスや技術的な決定を記録するために使用します。
